<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Successor</title>
    <link rel="stylesheet" href="./../style.css" /><link rel="stylesheet" href="./../lambs/cm/codemirror.css" />
    <script src="./../lambs/cm/codemirror.js" defer></script>
    <script src="./../lambs/match.js" defer></script>
    <script src="./../lambs/maybe.js" defer></script>
    <script src="./../lambs/exp.js" defer></script>
    <script src="./../lambs/parse.js" defer></script>
    <script src="./../lambs/unparse.js" defer></script>
    <script src="./../lambs/path.js" defer></script>
    <script src="./../lambs/redex.js" defer></script>
    <script src="./../lambs/eval.js" defer></script>
    <script src="./../lambs/repl.js" defer></script>
    <script src="./../lambs/editor.js" defer></script>
  </head>
  <body class="all-content">
    <div class="content">
      <p><a href="./../index.html">Index</a></p><p>2017-12-29</p>
      <h1>Successor</h1><p>We have made some numbers and some functions for working with numbers. Also some other datatypes.</p><p>We haven’t really done so here, but sometimes when we define numbers we fuss more about how they are constructed, about what the constructors are. We say things like: “A natural number is zero or it is the successor of a natural number.” (In a Standard ML we might say: “datatype nat = Zero | Succ of nat”)</p><p>We can do something similar but with the lambdas.</p><p>---</p><p>We already know what zero looks like:</p><pre name="lambs">0 ≜ λf.λx.x
</pre><p>We do not know that successor looks like:</p><pre name="lambs">S ≜ λn.λf.λx.f (n f x)
</pre><p>It takes a number, n, as its argument. S applied to n should return a number that is one larger than n.</p><p>(Remember: The number n is a function that, if given two arguments, applies the first argument n times to the second.)</p><p>So, S takes a number, n, as its argument, and returns one of those λf.λx.-functions. Within that function we do “n f x” (we apply n to f and x). This should amount to applying f “n times” to x. And then we apply f to the result of “n f x”, so that in total f should be applied “n+1 times” to x.</p><p>We can test it some and see if it looks right:</p><pre name="lambs">S 0

S (S 0)

S (S (S 0))

S (S (S (S (S 0))))
</pre><p>And like that’s it, that’s our successor. Maybe less impressive than the addition and multiplication functions we did earlier. But it’s kind of cool:</p><ul><li>We have zero-and-successor constructors. Much like the grown-ups have.</li><li>We can build any natural number with 0 and S. We have 0, and we can throw Ses at it until we have the number we really want.</li><li>Related: We kind of don’t really have to write the λf.λx.-bit ever again. Unless we want to. If we’re defining addition and we stick to 0 and S, we won’t have to do the λf.λx.-bit in order to construct the result-number.</li></ul><p>Will take a look at that last ting later.</p>
    </div>
  </body>
</html>