<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Code Mesh and infinite llamas</title>
    <link rel="icon" type="image/x-icon" href="./../assets/icon.png">
    <link rel="stylesheet" href="./../style.css">
  </head>
  <body class="post">
    <p><a href="./../index.html">Index</a></p><p>2017-11-08</p>
    <h1>Code Mesh and infinite llamas</h1><p>Kind of a companion post for a Code Mesh talk we did:</p><p><a href="http://www.codemesh.io/codemesh2017/jonas-winje">Infinite Lambda Calculus</a></p><ul class="links"><li><a href="https://github.com/Glorp/lambs/tree/mesh17">The code we used for the talk</a></li><li><a href="https://github.com/Glorp/lambs/blob/mesh17/lambs/mesh.txt">The file we ended up with in the talk (it is what it is)</a></li></ul><p><a href="./lambs.html">Also there are some lambdas over here</a></p><hr><p>Maybe the talk has a main point. Goes like this:</p><ul><li>We wanna get something like infinite, or at least pretty infinite, loops.</li><li>Lambda calculus is Turing complete, but it kind of wasn’t supposed to be?</li><li>Turing complete things can probably do infinite loops,</li><li>Type systems tend to get rid of like accidental Turing completeness.</li></ul><p>We can come up with a recipe for making a loopy thing:</p><ul><li>Look for a tiny expression that wouldn't typecheck if we had a type system-and-checker (if the type system doesn’t like an expression, then maybe that expression has something to do with Turing completeness and leads to infinite loops)</li><li>Type checkers sure don’t like <code>λx.x x</code></li><li><code>(λx.x x) (λx.x x)</code> goes on and on. Maybe for forever.</li><li>Adding e.g. <code>foo</code> like so: <code>(λx.x x) (λx.foo (x x))</code> will give us as many <code>foo</code>s as we want. Doing a few steps of evaluation will get us <code>foo (foo ((λx.foo (x x)) (λx.foo (x x))))</code>. If we do more steps we get more <code>foo</code>s.</li><li>We can do this with any <code>f</code>, instead of just with <code>foo</code>, because lambda abstraction: <code>λf.(λx.x x) (λx.f (x x))</code></li><li>One step of evaluation takes us from <code>λf.(λx.x x) (λx.f (x x))</code> to <code>λf.(λx.f (x x)) (λx.f (x x))</code></li></ul><br><p><code>λf.(λx.f (x x)) (λx.f (x x))</code> is the Y combinator :)</p>
  </body>
</html>