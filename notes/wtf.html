<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>How and when and under which circumstances is WTF?</title>
    <link rel="icon" type="image/x-icon" href="./../assets/icon.png">
    <link rel="stylesheet" href="./../style.css">
  </head>
  <body class="page">
    <p><a href="./../index.html">Index</a></p>
    <h1>How and when and under which circumstances is WTF?</h1><p>This has come up a couple of times: In JavaScript, <code>parseInt(0.0000005)</code> gives <code>5</code>:</p><ul><li>The argument to <code>parseInt</code> “should” be a string, but if you send something else it’s converted to a string.</li><li>Scientific notation because smol number.</li><li>If a string doesn’t look very integery, like if it has a bunch of letters in it or something, <code>parseInt</code> still returns a number if the <em>beginning</em> of the string looks like an integer.</li><li>The beginning of <code>&quot;5e-7&quot;</code> looks like 5.</li></ul><p>I think a lot of what’s going on is similar to many other WTFs and that it’s kind of at the same level of WTF as a fair amount of other ones. In my mind the main “weakness” here is that <code>parseInt</code> tries <em>so hard</em> to return a number. It’s mostly the “type coercion” but also the bit where it ignores the rest of the string because the beginning looks like an integer. It’s part of that JS territory that feels a little DWIM/evil genie.</p><p>I might be mistaken about this but, having seen it presented and reacted to a couple of times, my impression is that it works better as a WTF if you’re kind of fine with the DWIMy bits, but are surprised that it didn’t return a different number. Because you clearly meant zero, right? You entered a number that’s really close to zero and also the number literal looks a lot like the string literal <code>&quot;0.0000005&quot;</code> and <code>parseInt(&quot;0.0000005&quot;)</code> <em>does</em> give you <code>0</code>.</p><p>If you think that <code>parseInt(&lt;something that is not a string&gt;)</code> seems a little off to begin with, then maybe you expect <code>NaN</code> or an exception. And then it’s more like, oh, looks like it parsed <em>something</em>. You might not like that, but <em>which particular number</em> you get back is less interesting. If you chuck arbitrary non-string values at a string-parsing function it’s not <em>that</em> surprising that you don’t get back whichever number you had in mind. I mean the scientific notation bit can still be surprising but I dunno, maybe not WTF-surprising.</p><p>Maybe something like: With some of these WTFs it kind of seems like it’s a lot more WTF if you expect JS do to <em>more</em> magic and guess your intent more accurately.</p><p>(In some sense getting <code>5</code> back could be like, good, or at least better than <code>0</code>. Like if you’ve been using <code>parseInt</code> as a general “this, but an integer”-function, then that <code>5</code> might make you go look for a better way.)</p><p><a href="http://www.phpsadness.com/sad/47">Anyway there is actual gleefully unhinged stuff out there, like converting <em>both</em> the strings you’re comparing to numbers.</a></p>
  </body>
</html>