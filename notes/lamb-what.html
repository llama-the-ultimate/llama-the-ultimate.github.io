<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>What do the lambdas?</title>
    <link rel="icon" type="image/x-icon" href="./../assets/icon.png">
    <link rel="stylesheet" href="./../style.css">
    <link rel="stylesheet" href="./../cm/codemirror.css">
    <script src="./../cm/codemirror.js" defer></script>
    <script src="./../require.js" defer></script>
    <script src="./../lambs.js" defer></script>
    <script src="./../lambs-editor.js" defer></script>
  </head>
  <body class="page"><p><a href="./../index.html">Index</a></p><p><time>2017-07-24</time></p><h1>What do the lambdas?</h1><p><a href="./lambs.html">(There's a list with all the lambda notes here.)</a></p><p>An expression is one of the following:</p><ul><li><code>&lt;identifier&gt;</code> (variable reference)</li><li><code>Î»&lt;identifier&gt;.&lt;exp&gt;</code> (function abstraction, but sometimes weâ€™ll just call it a lambda)</li><li><code>&lt;exp&gt; &lt;exp&gt;</code> (function application)</li></ul><p>Is like tree. Variable references are leaves. Function application branches into two sub-trees, one for function and one for argument.</p><p>Function application is left associative. So <code>a b c</code> and <code>(a b) c</code> works out the same.</p><p>For example, can take a look at expression <code>(Î»a.a (foo a)) bar</code> and its sub-expressions:</p><ul><li><code>(Î»a.a (foo a)) bar</code> is a function application with a function <code>(Î»a.a (foo a))</code> and an argument <code>bar</code></li><li><code>Î»a.a (foo a)</code> is a function abstraction with a parameter <code>x</code> and a body <code>a (foo a)</code></li><li><code>a (foo a)</code> is a function application with a function <code>a</code> and argument <code>foo a</code></li><li><code>foo a</code> is a function application with a function <code>foo</code> and argument <code>a</code></li></ul><figure><svg width="26em" height="20em"><style>svg {stroke: currentColor;fill: none;}text {stroke: none;dominant-baseline: middle;text-anchor: middle;fill: currentColor;}</style><text x="56.73076923076923%" y="10%">(application)</text>
<text x="56.73076923076923%" y="15%">(Î»a.a (foo a)) bar</text>
<line x1="50%" y1="18.75%" x2="34.61538461538461%" y2="27.5%" />
<text x="34.61538461538461%" y="31.25%">(abstraction)</text>
<text x="33.65384615384615%" y="36.25%">Î»a.a (foo a)</text>
<line x1="62.5%" y1="18.75%" x2="77.88461538461539%" y2="27.5%" />
<text x="78.84615384615385%" y="30%">(reference)</text>
<text x="78.84615384615385%" y="35%">bar</text>
<line x1="32.69230769230769%" y1="40%" x2="32.69230769230769%" y2="43.75%" />
<text x="33.65384615384615%" y="47.5%">(application)</text>
<text x="32.69230769230769%" y="53.75%">a (foo a)</text>
<line x1="27.884615384615387%" y1="57.5%" x2="17.307692307692307%" y2="61.25%" />
<text x="15.384615384615385%" y="65%">(reference)</text>
<text x="14.423076923076923%" y="70%">a</text>
<line x1="35.57692307692308%" y1="57.5%" x2="46.15384615384615%" y2="61.25%" />
<text x="49.03846153846154%" y="65%">(application)</text>
<text x="48.07692307692308%" y="70%">foo a</text>
<line x1="44.23076923076923%" y1="73.75%" x2="34.61538461538461%" y2="78.75%" />
<text x="33.65384615384615%" y="81.25%">(reference)</text>
<text x="32.69230769230769%" y="86.25%">foo</text>
<line x1="52.88461538461539%" y1="73.75%" x2="60.57692307692308%" y2="78.75%" />
<text x="62.5%" y="81.25%">(reference)</text>
<text x="63.46153846153846%" y="86.25%">a</text></svg><figcaption>Syntax tree for <code>(Î»a.a (foo a)) bar</code></figcaption></figure><p>(So really, syntax is mostly like in an ML family language or a Haskell or something. Only instead of like, <code>fn x =&gt; foo</code> or <code>fun x -&gt; foo</code> or <code>x -&gt; foo</code>), we do <code>Î»x.foo</code>. Andalso thereâ€™s never any infix stuff for function application.)</p><hr><p>Evaluation is mostly: <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code>.</p><p>Meaning something like, a â€œreducible expressionâ€ (the bit to the left of the arrow) is:</p><ul><li>a function application</li><li>with a function-part that is a function abstraction, with some identifier <code>ğ±</code> as its parameter and some expression <code>ğ</code> as its body</li><li>and with an argument-part that is some expression <code>ğ€</code></li></ul><p>And if we have a reducible expression, then we can do â€œbeta reductionâ€: Substitute the argument <code>ğ€</code> for every free occurence of the parameter <code>ğ±</code> in the body <code>ğ</code>, and replace the whole function application with the result of that.</p><p>(The part that goes <code>[ğ€/ğ±]ğ</code> means that substitution thing: <code>ğ</code> but with every free <code>x</code> replaced with <code>ğ€</code>. So <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code> is a bit like a pattern match on the syntax of an expression. The expression to the left of the arrow binds the variables <code>ğ±</code> and <code>ğ</code> and <code>ğ€</code>, and the expression to the right uses them.)</p><p>Can try. With the expression <code>(Î»z.z bar) foo</code>, the parameter <code>ğ±</code> is <code>z</code>, the body <code>ğ</code> is <code>z bar</code>, and the argument <code>ğ€</code> is <code>foo</code>. So for this â€œinstanceâ€ of <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code> we get <code>(Î»z.z bar) foo âŸ¶ [foo/z]z bar</code>. It should evaluate to the body <code>z bar</code> with every free <code>z</code> replaced by the argument <code>foo</code>: <code>foo bar</code>.</p><figure><pre class="lambs-repl"><code>(Î»z.z bar) foo</code></pre></figure><p>A variable reference is free if it is not bound by a parameter in a function abstraction. With the expression <code>(Î»z.z (Î»z.bar z) bar) foo</code>, the parameter <code>ğ±</code> is <code>z</code>, the body <code>ğ</code> is <code>z (Î»z.bar z) bar</code>, and the argument <code>ğ€</code> is <code>foo</code>. Here, only the first <code>z</code> in the body <code>z (Î»z.bar z) bar</code> is free, so only that one is replaced with <code>foo</code>.</p><figure><pre class="lambs-repl"><code>(Î»z.z (Î»z.bar z) bar) foo</code></pre></figure><p>(In maybe more programmy jargon, we could maybe say that the inner <code>z</code> shadows the outer.)</p><p>Sometimes we have to change the names of some variables before doing beta reduction, in order to avoid having â€œvariable captureâ€ change the meaning of our expression. With the expression <code>(Î»x.Î»y.y x) y</code>, the parameter <code>ğ±</code> is <code>x</code>, the body <code>ğ</code> is <code>Î»y.y x</code>, and the argument <code>ğ€</code> is <code>y</code>. If we just replace the <code>x</code> in <code>Î»y.y x</code> with y, we get <code>Î»y.y y</code>. Our argument-y becomes bound (â€œcapturedâ€) by the parameter of the lambda within the body. Since we should be able to keep referring the outer <code>y</code>, we change the name of the parameter of the lambda (and all references to it) before we do beta reduction. (ctrl+enter two times, since the first one will just rename the parameter)</p><figure><pre class="lambs-repl"><code>(Î»x.Î»y.y x) y</code></pre></figure><hr><p>Thatâ€™s mostly it. We:</p><ul><li>look through our expression-tree in some order</li><li>maybe find a reducible expression</li><li>rename things if necessary</li><li>and do the substitution thing</li></ul><p>The order we look through the expression-tree is â€œnormal orderâ€. We check the outermost expression first, and then the function-parts of applications before the argument-parts. If we canâ€™t find any reducible expression, then the expression is on â€œnormal formâ€.</p><p>Typically we want to evaluate something down to normal form. So we run through those steps over and over until it is. (If weâ€™re unlucky that takes actually forever. But thatâ€™s kind of fun too.)</p><p>Can do (ctrl+shift+enter) to evaluate the following until itâ€™s on normal form:</p><figure><pre class="lambs-repl"><code>(Î»z.z foo) (Î»x.Î»y.x bar y) quux</code></pre></figure></body>
</html>
