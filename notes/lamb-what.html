<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>What do the lambdas?</title>
    <link rel="icon" type="image/x-icon" href="./../assets/icon.png">
    <link rel="stylesheet" href="./../style.css"><link rel="stylesheet" href="./../lambs/cm/codemirror.css">
    <script src="./../lambs/cm/codemirror.js" defer></script>
    <script src="./../lambs/match.js" defer></script>
    <script src="./../lambs/maybe.js" defer></script>
    <script src="./../lambs/exp.js" defer></script>
    <script src="./../lambs/parse.js" defer></script>
    <script src="./../lambs/unparse.js" defer></script>
    <script src="./../lambs/path.js" defer></script>
    <script src="./../lambs/redex.js" defer></script>
    <script src="./../lambs/eval.js" defer></script>
    <script src="./../lambs/repl.js" defer></script>
    <script src="./../lambs/editor.js" defer></script>
  </head>
  <body class="all-content">
    <div class="content">
      <p><a href="./../index.html">Index</a></p><p>2017-07-24</p>
      <h1>What do the lambdas?</h1><p><a href="./lambs.html">(There's a list with all the lambda notes here.)</a></p><p>An expression is one of the following:</p><ul><li><code>&lt;identifier&gt;</code> (variable reference)</li><li><code>Î»&lt;identifier&gt;.&lt;exp&gt;</code> (function abstraction, but sometimes weâ€™ll just call it a lambda)</li><li><code>&lt;exp&gt; &lt;exp&gt;</code> (function application)</li></ul><p>Is like tree. Variable references are leaves. Function application branches into two sub-trees, one for function and one for argument.</p><p>Function application is left associative. So <code>a b c</code> and <code>(a b) c</code> works out the same.</p><p>For example, can take a look at expression <code>(Î»a.a (foo a)) bar</code> and its sub-expressions:</p><ul><li><code>(Î»a.a (foo a)) bar</code> is a function application with a function <code>(Î»a.a (foo a))</code> and an argument <code>bar</code></li><li><code>Î»a.a (foo a)</code> is a function abstraction with a parameter <code>x</code> and a body <code>a (foo a)</code></li><li><code>a (foo a)</code> is a function application with a function <code>a</code> and argument <code>foo a</code></li><li><code>foo a</code> is a function application with a function <code>foo</code> and argument <code>a</code></li></ul><p><img src="./../assets/lambdatree.svg" alt="An expression tree for (Î»a.a (foo a)) bar"></p><p>(So really, syntax is mostly like in an ML family language or a Haskell or something. Only instead of like, <code>fn x =&gt; foo</code> or <code>fun x -&gt; foo</code> or <code>x -&gt; foo</code>), we do <code>Î»x.foo</code>. Andalso thereâ€™s never any infix stuff for function application.)</p><hr><p>Evaluation is mostly: <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code>.</p><p>Meaning something like, a â€œreducible expressionâ€ (the bit to the left of the arrow) is:</p><ul><li>a function application</li><li>with a function-part that is a function abstraction, with some identifier <code>ğ±</code> as its parameter and some expression <code>ğ</code> as its body</li><li>and with an argument-part that is some expression <code>ğ€</code></li></ul><p>And if we have a reducible expression, then we can do â€œbeta reductionâ€: Substitute the argument <code>ğ€</code> for every free occurence of the parameter <code>ğ±</code> in the body <code>ğ</code>, and replace the whole function application with the result of that.</p><p>(The part that goes <code>[ğ€/ğ±]ğ</code> means that substitution thing: <code>ğ</code> but with every free <code>x</code> replaced with <code>ğ€</code>. So <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code> is a bit like a pattern match on the syntax of an expression. The expression to the left of the arrow binds the variables <code>ğ±</code> and <code>ğ</code> and <code>ğ€</code>, and the expression to the right uses them.)</p><p>Can try. With the expression <code>(Î»z.z bar) foo</code>, the parameter <code>ğ±</code> is <code>z</code>, the body <code>ğ</code> is <code>z bar</code>, and the argument <code>ğ€</code> is <code>foo</code>. So for this â€œinstanceâ€ of <code>(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ</code> we get <code>(Î»z.z bar) foo âŸ¶ [foo/z]z bar</code>. It should evaluate to the body <code>z bar</code> with every free <code>z</code> replaced by the argument <code>foo</code>: <code>foo bar</code>.</p><pre class="lambs">(Î»z.z bar) foo
</pre><p>A variable reference is free if it is not bound by a parameter in a function abstraction. With the expression <code>(Î»z.z (Î»z.bar z) bar) foo</code>, the parameter <code>ğ±</code> is <code>z</code>, the body <code>ğ</code> is <code>z (Î»z.bar z) bar</code>, and the argument <code>ğ€</code> is <code>foo</code>. Here, only the first <code>z</code> in the body <code>z (Î»z.bar z) bar</code> is free, so only that one is replaced with <code>foo</code>.</p><pre class="lambs">(Î»z.z (Î»z.bar z) bar) foo
</pre><p>(In maybe more programmy jargon, we could maybe say that the inner <code>z</code> shadows the outer.)</p><p>Sometimes we have to change the names of some variables before doing beta reduction, in order to avoid having â€œvariable captureâ€ change the meaning of our expression. With the expression <code>(Î»x.Î»y.y x) y</code>, the parameter <code>ğ±</code> is <code>x</code>, the body <code>ğ</code> is <code>Î»y.y x</code>, and the argument <code>ğ€</code> is <code>y</code>. If we just replace the <code>x</code> in <code>Î»y.y x</code> with y, we get <code>Î»y.y y</code>. Our argument-y becomes bound (â€œcapturedâ€) by the parameter of the lambda within the body. Since we should be able to keep referring the outer <code>y</code>, we change the name of the parameter of the lambda (and all references to it) before we do beta reduction. (ctrl+enter two times, since the first one will just rename the parameter)</p><pre class="lambs">(Î»x.Î»y.y x) y
</pre><hr><p>Thatâ€™s mostly it. We:</p><ul><li>look through our expression-tree in some order</li><li>maybe find a reducible expression</li><li>rename things if necessary</li><li>and do the substitution thing</li></ul><p>The order we look through the expression-tree is â€œnormal orderâ€. We check the outermost expression first, and then the function-parts of applications before the argument-parts. If we canâ€™t find any reducible expression, then the expression is on â€œnormal formâ€.</p><p>Typically we want to evaluate something down to normal form. So we run through those steps over and over until it is. (If weâ€™re unlucky that takes actually forever. But thatâ€™s kind of fun too.)</p><p>Can do (ctrl+shift+enter) to evaluate the following until itâ€™s on normal form:</p><pre class="lambs">(Î»z.z foo) (Î»x.Î»y.x bar y) quux
</pre>
    </div>
  </body>
</html>