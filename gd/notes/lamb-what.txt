# What do the lambdas?
:blurb Some lambda calculus syntax and semantics.
:date 2017-07-24
:special lambda

=> gd lambs.txt (There's a list with all the lambda notes here.)

An expression is one of the following:
* `<identifier>` (variable reference)
* `Î»<identifier>.<exp>` (function abstraction, but sometimes weâ€™ll just call it a lambda)
* `<exp> <exp>` (function application)

Is like tree. Variable references are leaves. Function application branches into two sub-trees, one for function and one for argument.

Function application is left associative. So `a b c` and `(a b) c` works out the same.

For example, can take a look at expression `(Î»a.a (foo a)) bar` and its sub-expressions:

* `(Î»a.a (foo a)) bar` is a function application with a function `(Î»a.a (foo a))` and an argument `bar`
* `Î»a.a (foo a)` is a function abstraction with a parameter `x` and a body `a (foo a)`
* `a (foo a)` is a function application with a function `a` and argument `foo a`
* `foo a` is a function application with a function `foo` and argument `a`

<= img /assets/lambdatree.svg An expression tree for `(Î»a.a (foo a)) bar`

(So really, syntax is mostly like in an ML family language or a Haskell or something. Only instead of like, `fn x => foo` or `fun x -> foo` or `\x -> foo`), we do `Î»x.foo`. Andalso thereâ€™s never any infix stuff for function application.)

----

Evaluation is mostly: `(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ`.

Meaning something like, a â€œreducible expressionâ€ (the bit to the left of the arrow) is:

* a function application
* with a function-part that is a function abstraction, with some identifier `ğ±` as its parameter and some expression `ğ` as its body
* and with an argument-part that is some expression `ğ€`

And if we have a reducible expression, then we can do â€œbeta reductionâ€: Substitute the argument `ğ€` for every free occurence of the parameter `ğ±` in the body `ğ`, and replace the whole function application with the result of that.

(The part that goes `[ğ€/ğ±]ğ` means that substitution thing: `ğ` but with every free `x` replaced with `ğ€`. So `(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ` is a bit like a pattern match on the syntax of an expression. The expression to the left of the arrow binds the variables `ğ±` and `ğ` and `ğ€`, and the expression to the right uses them.)

Can try. With the expression `(Î»z.z bar) foo`, the parameter `ğ±` is `z`, the body `ğ` is `z bar`, and the argument `ğ€` is `foo`. So for this â€œinstanceâ€ of `(Î»ğ±.ğ) ğ€ âŸ¶ [ğ€/ğ±]ğ` we get `(Î»z.z bar) foo âŸ¶ [foo/z]z bar`. It should evaluate to the body `z bar` with every free `z` replaced by the argument `foo`: `foo bar`.

``` repl
(Î»z.z bar) foo
```

A variable reference is free if it is not bound by a parameter in a function abstraction. With the expression `(Î»z.z (Î»z.bar z) bar) foo`, the parameter `ğ±` is `z`, the body `ğ` is `z (Î»z.bar z) bar`, and the argument `ğ€` is `foo`. Here, only the first `z` in the body `z (Î»z.bar z) bar` is free, so only that one is replaced with `foo`.

``` repl
(Î»z.z (Î»z.bar z) bar) foo
```

(In maybe more programmy jargon, we could maybe say that the inner `z` shadows the outer.)

Sometimes we have to change the names of some variables before doing beta reduction, in order to avoid having â€œvariable captureâ€ change the meaning of our expression. With the expression `(Î»x.Î»y.y x) y`, the parameter `ğ±` is `x`, the body `ğ` is `Î»y.y x`, and the argument `ğ€` is `y`. If we just replace the `x` in `Î»y.y x` with y, we get `Î»y.y y`. Our argument-y becomes bound (â€œcapturedâ€) by the parameter of the lambda within the body. Since we should be able to keep referring the outer `y`, we change the name of the parameter of the lambda (and all references to it) before we do beta reduction. (ctrl+enter two times, since the first one will just rename the parameter)

``` repl
(Î»x.Î»y.y x) y
```

----

Thatâ€™s mostly it. We:

* look through our expression-tree in some order
* maybe find a reducible expression
* rename things if necessary
* and do the substitution thing

The order we look through the expression-tree is â€œnormal orderâ€. We check the outermost expression first, and then the function-parts of applications before the argument-parts. If we canâ€™t find any reducible expression, then the expression is on â€œnormal formâ€.

Typically we want to evaluate something down to normal form. So we run through those steps over and over until it is. (If weâ€™re unlucky that takes actually forever. But thatâ€™s kind of fun too.)

Can do (ctrl+shift+enter) to evaluate the following until itâ€™s on normal form:

``` repl
(Î»z.z foo) (Î»x.Î»y.x bar y) quux
```
